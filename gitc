#! /bin/bash

PROMPT_COMMIT_MESSAGE="Summarize the following code changes as a concise commit message."

PROMPT_REVIEW="Review the following code changes and provide a feedback. Do you see any potential issues or bugs?"

yellow_text() {
  echo -e "\033[1;33m$1\033[0m"
}

red_text() {
  echo -e "\033[1;31m$1\033[0m"
}

green_text() {
  echo -e "\033[1;32m$1\033[0m"
}

print_usage() {
  echo "Usage: gitc [-a] [path]"
  echo "  -a: Add all changes"
  echo "  path: Path to commit"
}

gitc() {
  local auto_add=false

  prompt=$PROMPT_COMMIT_MESSAGE
  diff_command=(git diff --cached)
  temperature=0.2
  max_tokens=40
  model="gpt-4.1"
  review_requested=false

  git_root=$(git rev-parse --show-toplevel)

  while getopts "ahr" opt; do
    case ${opt} in
      a)
        auto_add=true
        ;;
      r)
        diff_command=(git diff --cached -U20)
        max_tokens=1000
        PROMPT=$PROMPT_REVIEW
        model="o4-mini-high"
        review_requested=true
        ;;
      h)
        print_usage
        return 0
        ;;
      *)
        print_usage
        return 0
        ;;
    esac
  done

  shift $((OPTIND - 1))  # Shift away parsed options

  path_to_commit=$1

  DIFF=$("${diff_command[@]}")

  if [ -n "$path_to_commit" ]; then
    if [ -n "$DIFF" ]; then
      red_text "Refusing to commit a specific path with already staged changes."
      return 1
    elif [ "$auto_add" = true ]; then
      red_text "Cannot use -a flag with a specific path."
      return 1
    fi
    echo "Adding $path_to_commit"
    git add --verbose "$path_to_commit"
    DIFF=$("${diff_command[@]}")
  fi

  if [ "$auto_add" = true ]; then
    if [ -z "$DIFF" ]; then
      yellow_text "Adding all changes."
      git add --verbose "$git_root"
      DIFF=$("${diff_command[@]}")
    else
      red_text "Cannot use -a flag with already staged changes."
      return 1
    fi
  fi

  if [ -z "$DIFF" ]; then
    yellow_text "No diff detected."
    return 0
  fi

  if [ -f "$git_root/.pre-commit-config.yaml" ]; then
    pre-commit run
    if [ $? -ne 0 ]; then
      red_text "Pre-commit hooks failed. Please fix the issues and try again."
      return 1
    fi
  fi

  if [ -z "$OPENAI_API_KEY" ]; then
    red_text "OPENAI_API_KEY is not set. Please set it and try again."
    git reset --soft
    return 1
  fi

  # JSON-escape the diff
  JSON_DIFF=$(jq -Rs . <<< "$DIFF")

  # Call the OpenAI API to generate a commit message
  COMMIT_MSG=$(curl -s https://api.openai.com/v1/chat/completions \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -d "{
          \"model\": \"$model\",
          \"messages\": [
            {\"role\": \"system\", \"content\": \"$prompt\"},
            {\"role\": \"user\", \"content\": $JSON_DIFF}
          ],
          \"temperature\": $temperature,
          \"max_tokens\": $max_tokens
        }" \
    | jq -r ".choices[0].message.content")

  # Check if the API returned a message
  if [ -z "$COMMIT_MSG" ]; then
    red_text "Failure to call API"
    git reset --soft
    return
  fi

  if [ "$review_requested" = true ]; then
    yellow_text "$COMMIT_MSG"
    return 0
  fi

  # pre-commit already ran
  git commit -m "$COMMIT_MSG" --no-verify

  # Ask the user if they want to run git push
  if [ -n "$ZSH_VERSION" ]; then
    read "push_answer?Do you want to run 'git push'? [y/N]: "
  else
    read -p "Do you want to run 'git push'? [y/N]: " push_answer
  fi

  if [[ "$push_answer" =~ ^[Yy]$ ]]; then
    git push
  fi
}
